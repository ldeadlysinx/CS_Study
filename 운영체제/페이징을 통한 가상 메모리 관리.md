# 페이징을 통한 가상 메모리 관리

개요: 연속 메모리 할당의 두 가지 문제점

 - 외부 단편화
 - 물리 메모리보다 큰 프로세스 실행 불가

**페이징**

- 외부 단편화가 근본적으로 발생하는 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되기 때문이다. 이를 위한 해결법이 페이징이다.\

정의)프로세스를 일정 크기로 자르고, 이를 메모리에 불연속적으로 할당하는 방법

 - 프로세스의 몬리 주소 공간을 페이지라는 일정 단위로 자르고
 - 메모리의 물리 주소 공간을 프레임이라는 페이지와 동일한 일정한 단위로 자른 뒤
 - 페이지를 프레임에 할당하는 가상 메모리 관리 기법

프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다.

문제점

 - 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU 가 일일이 알기란 어렵다.
 - 프로세스가 메모리에 줄연속으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할수가 없다.
 - CPU 입장에서 다음에 실행할 명령어 위치를 찾기가 어려워짐

**페이지 테이블**

 - 물리 주소에 불연속적으로 배치되더라도
 - 논리 주소에는 연속적으로 배치되도록 하는 방법
 - 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표

단점) 내부 단편화 발생: 하나의 페이지 크기보다 작은 크기로 발생

**PTBR**

 - 프로세스마다 페이지 테이블이 있고
 - 각 페이지 테이블은 CPU 내의 프로세스 테이블 베이스 레지스터가 가리킨다.
 
 단점) 페이지 테이블이 모두 메모리에 저장되어 있다면 접근 시간이 두배로 늘어난다. 메모리에 있는 페이지 테이블을 보기 위해 그리고 프레임에 접근하기 위해 한번

TLB
위와 같은 단점을 해결하기 위한 방법
정의) CPU 곁에 페이지 테이블의 캐시 메모리

 - CPU가 접근하려는 논리 주소가 TLB에 있다면? TLB 히트 
 - CPU가 접근하려는 논리 주소가 TLB에 없다면? TLB 미스

**페이징에서의 주소 변환**

 - 어떤 페이지 혹은 프레임에 접근하고 싶은지
 - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지

논리 주소가 기본적으로 페이지 번호 변위로 이루어져있다.

**페이지 테이블 엔트리**

 1. 유효 비트 :  현재 해당 페이지에 접근 가능한지 여부
	유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면 페이지 폴트라는 예외가 발생한다.

2. 보호 비트: 페이지 보호 기능을 위해 존재하는 비트 0일때는 읽기만 가능 1일때는 읽고 쓰기 가능

3. 참조 비트: CPU 가 이 페이지에 한번이라도 접근한적이 있는지 확인하는 비트

4. 수정비트: CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부
	수정된 적이 있는 페이지가 스왑 아웃될 경우 변경된 값을 보조기억장치에 		 덮어씌어야하는 작업이 추가되어하기 때문에 사용된다.
	

## 페이지 교체와 프레임 할당

 - 물리 메모리의 크기는 한정되어 있다.
 - 기존에 적재된 불필요한 페이지를 선별해 보조기억장치로 내보내고
 - 프로세스들에게 적적한 수의 프레임을 할당해야한다.

**요구 페이징**
	- 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
	- 요구되는 페이지만 적재하는 기법
	
**페이지 교체 알고리즘**
-  페이지 폴트가 적은 알고리즘(좋은 페이지 교체 알고리즘)
	- 페이지 폴트가 발생하면 보조기억장치에 접근해야 해서 성능 저하

- 페이지 참조열
	- CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열

1.FIFO 페이지 교체 알고리즘
- 가장 단순한 방식
- 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
- 오래 머물러있을경우 나간다.
단점)  
프로그램 실행 내내 사용될 페이지를 오래되었다고 쫓아내므로 실행에 장애가 생김

보완책) 
2차 기회 페이지 교체 알고리즘
 - 참조 비트 1: CPU가 한 번 참조한 적이 있는 페이지
 - 참조 비트0: CPU가 참조한 적이 없는 페이지
 CPU 가 참조한적이 있다면 내쫓지 않고 참조비트를 0으로 바구고 다음에 바꾼다. 참조비트가 0인경우에는 바로 내쫓긴다

2. 최적 페이지 교체 알고리즘
- CPU에 의해 참조되는 횟수를 고려
- 메모리에 오래 남아야 할 페이지는 자주 사용될 페이지
- 메모리에 업어도 될 페이지는 오랫동안 사용되지 않을 페이지

단점)
실제 구현은 어렵다 앞으로 오랫동안 사용되지 않을 페이지 예측 불가

3. LRU 페이지 교체 알고리즘
- 최근에 사용되지 않은 페이지는 오래되지 않은 페이지라고 가정
- 가장 오랫동안 사용되지 않은 페이지를 교체

**스래싱과 프레임 할당**

- 페이지 폴트가 자주 발생하는 이유
	- 나쁜 페이지 교체 알고리즘을 사용해서
	- 프로세스가 사용할 수 있는 프레임 자체가 적어서

1. 스래싱
- 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제
- 동시 실행되면 어느정도는 이용률이 높아지는데 많이 사용할경우 스래싱이 발생 CPU성능이 떨어진다.(페이지 폴트가 많이 발생하여 성능저하)
- 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해줘야 한다.

해결책)
- 균등할당
	- 가장 단순한 할당 방식
	- 모든 프로세스들에게 균등하게 프레임을 할당하는 방식

	단점) 
	매우 비효율 크기가 큰 프로세스는 적은 수의 프레임을 할당받아 실행에 문		제가 생길수 있다.

- 비례 할당
	- 프로세스의 크기에 비례하여 프레임 할당

	단점) 
	프로세스의 크기가 클지라도 실행해 보면 많은 프레임을 필요로 하지 않은 경우도 있다. 반대 경우도 있다.

- 작업 집합 모델
	- 프로세스가 실행하는 과정에서 배분할 프레임 결정
	- 스레싱이 발생하는 이유는 빈번한 페이지 교체 때문
	-  그러므로 CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당하면 된다.


